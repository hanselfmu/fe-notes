function getUberShader(){return"//defines from app, these correspond to different effects/techniques\n#ifdef LIGHTING_VERTEX\n	#define VERTEX_LIGHTING\n#endif\n#ifdef LIGHTING_FRAGMENT_GEOMETRY\n	#define FRAGMENT_VIEW_SPACE_LIGHTING\n#endif\n#ifdef LIGHTING_FRAGMENT_BUMP\n	#define FRAGMENT_TANGENT_SPACE_LIGHTING\n#endif\n#ifdef LIGHTING_FRAGMENT_RELIEF\n	#define FRAGMENT_TANGENT_SPACE_LIGHTING\n	#define NEED_HEIGHT_MAP\n#endif\n\n#if defined(EFFECT_REFLECTION) || defined(EFFECT_FRESNEL)\n	#define NEED_ENVIRONMENT_MAP\n	//reflection and fresnel need normals and positions as input so make sure there is AT LEAST FRAGMENT_NEED_VIEW_SPACE_INPUT defined (the FRAGMENT_NEED_TANGENT_SPACE_INPUT flag is stronger and will override this if defined)\n	#define FRAGMENT_NEED_VIEW_SPACE_INPUT\n#endif\n\n//more specific defines\n#ifdef FRAGMENT_VIEW_SPACE_LIGHTING\n	#define FRAGMENT_NEED_VIEW_SPACE_INPUT\n#elif defined(FRAGMENT_TANGENT_SPACE_LIGHTING)\n	#define FRAGMENT_NEED_TANGENT_SPACE_INPUT\n	#define NEED_NORMAL_MAP\n	\n#endif\n\n\n#if defined(VERTEX_SHADER) && defined(VERTEX_LIGHTING)\n	#define NEED_LIGHT_POSITION	\n#elif defined(FRAGMENT_SHADER) && defined(FRAGMENT_NEED_VIEW_SPACE_INPUT)\n	#define NEED_LIGHT_POSITION	\n	#define NEED_LIGHT_COLOR	\n#elif defined(FRAGMENT_SHADER) && defined(VERTEX_LIGHTING)\n	#define NEED_LIGHT_COLOR	\n#else\n	#if defined(VERTEX_SHADER) && defined(FRAGMENT_NEED_TANGENT_SPACE_INPUT)\n		#define NEED_LIGHT_POSITION	\n	#endif\n	#if defined(FRAGMENT_SHADER) && defined(FRAGMENT_NEED_TANGENT_SPACE_INPUT)\n		#define NEED_LIGHT_POSITION	\n		#define NEED_LIGHT_COLOR	\n	#endif\n#endif\n\n#define NEED_UV_COORDINATES\n\n//common functions\n\n//calculate diffuse intensity (vec2.x) and specular intensity (vec2.y) (view space assumed)\nvec2 calculateLightIntensities(vec3 point, vec3 normal, vec3 lightPos, float lightIntensity, float shininess) \n{\n	vec2 intensities;\n\n	vec3 lightDir = lightPos - point;\n	float magn = length(lightDir);\n	float intensity = lightIntensity / magn;\n	\n	//diffuse \n	intensities.x = clamp( dot( normal,  lightDir / magn ), .0, 1.0 ) * intensity;\n	\n	//add specular\n	vec3 halfVec = normalize(-point + lightDir);\n	intensities.y = pow( clamp( dot( halfVec, normal), 0.0 ,1.0) , shininess) * intensity;\n	\n	return  intensities;\n}\n\n//[0..1] -> [-1..1]\nvec3 unpackNormal(vec3 n) {\n	return (n - 0.5) * 2.0;\n}\n\n//relief mapping offset\nvec2 calculateOffsetUvCoordinatesFromHeightmap(sampler2D heightMap,vec3 normalizedCamDirection, vec2 originalUv, float heightScale)\n{\n	const int linearSearchSteps = 10;\n	const int binarySearchSteps = 10;\n	const float heightDeltaPerStep = 1.0 / float(linearSearchSteps);\n	vec2 tanDelta = normalizedCamDirection.xy * heightScale / normalizedCamDirection.z;\n\n	float bestHeight = 0.0;\n	float currentHeight = heightDeltaPerStep;\n\n\n	//find the coarse intersection with linear stepping\n	for( int i = 0; i < (linearSearchSteps - 1); ++i)\n	{\n		float height =  texture2D(heightMap, originalUv + currentHeight * tanDelta).r;\n		if (height > currentHeight)\n		{\n			bestHeight = currentHeight;\n		}\n		currentHeight += heightDeltaPerStep;\n	}\n\n	currentHeight = bestHeight;\n	float currentDeltaPerStep = heightDeltaPerStep;\n\n	//use binary search to find more accurate intersection\n	for( int i = 0; i < binarySearchSteps; ++i )\n	{\n		currentDeltaPerStep *= 0.5;\n		currentHeight += currentDeltaPerStep;\n		float height = texture2D(heightMap, originalUv + currentHeight * tanDelta).r;\n		if(height > currentHeight)\n		{\n			bestHeight = currentHeight;\n			currentHeight += currentDeltaPerStep;\n		} else {\n			currentHeight -= 2.0 * currentDeltaPerStep;\n		}\n\n	}\n\n\n	return originalUv + bestHeight * tanDelta;\n\n\n}\n\n\n//calculate outline from normal (celshading)\nfloat calculateOutline(vec3 normal, vec3 viewDir) {\n	return step(0.3, dot(normal, viewDir) );\n}\n\n//return value if the val is between ]edge1, edge2]\nfloat ramp(float val, float edge1, float edge2) {\n	return (1.0 - step(val, edge1)) * step(val, edge2);\n\n}\n\n//quantify gradient Specular (celshading)\nfloat quantifySpecular(float originalIntensity){\n	float intensity;\n	intensity = ramp(originalIntensity, -0.1, 0.9) * 0.0;\n	intensity += step(0.9, originalIntensity) * 6.0;\n\n	return intensity;\n\n\n}\n//quantify gradient Diffuse (celshading)\nfloat quantifyDiffuse(float originalIntensity){\n	float intensity;\n	intensity = ramp(originalIntensity, -0.1, 0.3) * 0.1;\n	intensity += ramp(originalIntensity, 0.3, 0.8) * 0.2;\n     intensity += step(0.8, originalIntensity) * 0.5;\n\n	return intensity;\n\n\n}\n\n//the reference direction is usually either normal or the  half vector of lightDir + viewDir.\nvec3 fresnelSchlick(vec3 viewDir, vec3 referenceDir, vec3 R ) {\n	\n	return R + (vec3(1.0) - R) * pow(1.0 -   max( dot(viewDir, referenceDir), 0.0 ), 5.0);\n}\n			\n\n\n//uniforms\n\n//surface material\nuniform vec3 ambience;\nuniform sampler2D albedo;\nuniform vec4 specularColorShininess;\nuniform vec3 RefractionIndices;\nuniform float reliefDepthScale;\n\n#ifdef NEED_LIGHT_POSITION\n//lights position in world space and it's intensity\nuniform vec4 lightPosInt;\n#endif\n\n#ifdef NEED_LIGHT_COLOR\nuniform vec3 lightColor;\n#endif\n\n#if defined(NEED_NORMAL_MAP) && defined(FRAGMENT_SHADER)\nuniform sampler2D bumpMap;\n#endif\n\n#if defined(NEED_HEIGHT_MAP)\nuniform sampler2D heightMap;\n#endif\n\n#if defined(NEED_ENVIRONMENT_MAP) && defined(FRAGMENT_SHADER)\nuniform samplerCube environmentMap;\nuniform mat3 invViewMatrix;\n#endif\n\n\n\n\n//attributes\n#ifdef VERTEX_SHADER\n	#ifdef FRAGMENT_NEED_TANGENT_SPACE_INPUT\nattribute vec4 tangent;\n	#endif\n#endif\n			\n//varyings\n#ifdef VERTEX_LIGHTING\nvarying vec2 lightIntensities;\n	#ifdef EFFECT_CEL_SHADING\nvarying float outline;\n	#endif\n#endif\n\n#if defined(FRAGMENT_NEED_TANGENT_SPACE_INPUT)\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#elif defined(FRAGMENT_NEED_VIEW_SPACE_INPUT)\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n#endif\n\n\n\n#ifdef LIGHTING_FRAGMENT_RELIEF\nvarying vec3 tangentCamPos;\n#endif\n\n#ifdef NEED_UV_COORDINATES\nvarying vec2 uv1;\n#endif\n\n//vertex shader specific code\n#ifdef VERTEX_SHADER\nvoid main()	{\n	vec4 viewPos = modelViewMatrix * vec4(position, 1.0);\n	\n#if defined(VERTEX_LIGHTING) || defined(FRAGMENT_NEED_VIEW_SPACE_INPUT) || defined(FRAGMENT_NEED_TANGENT_SPACE_INPUT)\n	vec3 n = normalize(normalMatrix * normal);\n#endif\n	\n#ifdef VERTEX_LIGHTING\n	vec2 intensities = calculateLightIntensities(viewPos.xyz, n, (viewMatrix * vec4(lightPosInt.xyz, 1.0)).xyz, lightPosInt.w, specularColorShininess.w);\n	\n	#ifdef EFFECT_CEL_SHADING\n	intensities.x = quantifyDiffuse(intensities.x);\n	intensities.y = quantifySpecular(intensities.y);\n	#endif\n	\n	#ifdef EFFECT_CEL_SHADING\n	outline = calculateOutline(n, vec3(0.0, 0.0, 1.0));\n	#endif\n	\n	lightIntensities = intensities;\n	\n#endif\n#if defined(FRAGMENT_NEED_TANGENT_SPACE_INPUT)\n	vec3 bitangent = cross( normal, tangent.xyz ) * tangent.w;\n\n	vPosition = viewPos.xyz;\n	vNormal = n;\n	vTangent = normalize(normalMatrix * tangent.xyz);\n	vBitangent = normalize(normalMatrix * bitangent);\n\n	#if defined(LIGHTING_FRAGMENT_RELIEF)\n	vec3 camView = (viewMatrix * vec4(cameraPosition,1.0)).xyz - viewPos.xyz;\n	tangentCamPos = vec3(\n		dot(vTangent, camView),\n		dot(vBitangent, camView),\n		dot(vNormal, camView)	\n	);\n	#endif\n#elif defined(FRAGMENT_NEED_VIEW_SPACE_INPUT)\n	vNormal = n;\n	vPosition = viewPos.xyz;\n#endif\n	\n	\n	\n#ifdef NEED_UV_COORDINATES\n	uv1 = uv;\n#endif\n\n	gl_Position = projectionMatrix * viewPos;\n\n}\n\n\n#endif\n\n\n//fragment shader specific code\n#ifdef FRAGMENT_SHADER\n\nvoid main()	{\n	vec3 finalColor;\n	\n#ifdef NEED_UV_COORDINATES\n	vec2 uvCoords = uv1; \n	#ifdef LIGHTING_FRAGMENT_RELIEF\n		\n		uvCoords = calculateOffsetUvCoordinatesFromHeightmap(heightMap, normalize(tangentCamPos), uvCoords, reliefDepthScale);\n	#endif\n#endif\n	\n#ifdef VERTEX_LIGHTING\n	vec2 intensities = lightIntensities;\n#else\n	\n	#if defined(FRAGMENT_NEED_TANGENT_SPACE_INPUT) || defined(FRAGMENT_NEED_VIEW_SPACE_INPUT)\n	vec3 objPos = vPosition;\n	vec3 lightPos =  (viewMatrix * vec4(lightPosInt.xyz, 1.0)).xyz;\n	#endif\n	\n	#if defined(FRAGMENT_NEED_TANGENT_SPACE_INPUT)\n	vec3 objNormal = unpackNormal(texture2D(bumpMap, uvCoords).xyz);\n	objNormal = normalize( objNormal.x * vTangent + objNormal.y * vBitangent + objNormal.z * vNormal);\n	#elif defined(FRAGMENT_NEED_VIEW_SPACE_INPUT)\n	vec3 objNormal = normalize(vNormal);\n	#endif\n\n	#if defined(FRAGMENT_VIEW_SPACE_LIGHTING) || defined(FRAGMENT_TANGENT_SPACE_LIGHTING)\n	vec2 intensities = calculateLightIntensities(objPos, objNormal, lightPos,  lightPosInt.w, specularColorShininess.w);\n	\n		#ifdef EFFECT_CEL_SHADING\n	intensities.x = quantifyDiffuse(intensities.x);\n	intensities.y = quantifySpecular(intensities.y);\n		#endif\n	#endif\n	\n#endif\n	vec3 diffuseColor = texture2D(albedo, uvCoords).xyz;\n	\n#if defined(FRAGMENT_VIEW_SPACE_LIGHTING) || defined(FRAGMENT_TANGENT_SPACE_LIGHTING) || defined(VERTEX_LIGHTING)\n	finalColor = (intensities.x * diffuseColor + intensities.y * specularColorShininess.xyz) * lightColor;\n#else\n	//there is no lighting at all.\n	finalColor = vec3(0.0, 0.0, 0.0);\n#endif\n	\n#if defined(EFFECT_REFLECTION) || defined(EFFECT_FRESNEL)\n	//need to calculate reflection in world space. Assume view matrix is orthogonal.\n	mat3 vmat = mat3(viewMatrix);\n	vec3 wViewDir = normalize( objPos * vmat );\n	vec3 wObjNormal = normalize( objNormal * vmat);\n	vec3 reflDir = reflect(wViewDir, wObjNormal);\n	vec3 reflColor = textureCube(environmentMap, reflDir).rgb * diffuseColor * ambience;  //incorrect but try to make up for the missing specular map \n#endif\n	\n#ifdef EFFECT_CEL_SHADING\n	#ifdef VERTEX_LIGHTING\n	finalColor *= outline;\n	#else\n	finalColor *= calculateOutline(objNormal, normalize(-objPos));\n	#endif\n#endif\n//either use reflection (or reflection + refraction) for ambience, or constant ambience\n#ifdef EFFECT_REFLECTION\n	finalColor += reflColor;\n#elif defined(EFFECT_FRESNEL)\n	\n	vec3 refrDir = refract(wViewDir, wObjNormal, RefractionIndices.r);\n	float refrColorR = textureCube(environmentMap, refrDir).r;\n	\n	refrDir = refract(wViewDir, wObjNormal, RefractionIndices.g);\n	float refrColorG = textureCube(environmentMap, refrDir).g;\n	\n	refrDir = refract(wViewDir, wObjNormal, RefractionIndices.b);\n	float refrColorB = textureCube(environmentMap, refrDir).b;\n	\n	vec3 refrColor = vec3(refrColorR, refrColorG, refrColorB);\n	\n	vec3 fresnelTerm = fresnelSchlick(-wViewDir, wObjNormal, specularColorShininess.rgb );\n		\n	finalColor +=  mix(refrColor * diffuseColor, reflColor, fresnelTerm);\n#else\n	finalColor += ambience;\n#endif\n\n\n	gl_FragColor=vec4(finalColor, 1.0);\n}\n\n\n#endif\n\n\n"}