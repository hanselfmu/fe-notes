<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Basemark Web 3.0 | Main page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Modernizr -->
    <script type="text/javascript" src="/js/run/modernizr.min.js"></script>

    <!-- Engine -->
    <script type="text/javascript" src="/js/run/BasemarkWebEngine.js"></script>

    <style type="text/css">
        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }
        body {
            margin: 0;
            font-family: 'Open Sans', sans-serif;
        }
        #brand-header {
            background-color: #00a2ff;
            height: 70px;
            margin-right: auto;
            margin-left: auto;
            padding-left: 15px;
            padding-right: 15px;
        }
        #brand-header img {
            height: 55px;
            margin-top: 7px;
        }

    </style>
</head>
<style>
    body { margin: 0; }
    canvas { width: 100%; height: 100% }
</style>

<script type="text/javascript" src="../__includes/GraphicsTestBase.js"></script><script type="text/javascript" src="../__includes/three.min.js"></script><script type="text/javascript" src="../__includes/full_scene/includes/control.js"></script><script type="text/javascript" src="../__includes/ColladaLoader.js"></script><script type="text/javascript" src="../__includes/full_scene/includes/dat.gui.min.js"></script><script type="text/javascript" src="../__includes/Utilities.js"></script><script type="text/javascript" src="../__includes/full_scene/includes/PostProcess/PostProcessShaders.js"></script><script type="text/javascript" src="../__includes/full_scene/includes/PostProcess/Compositor.js"></script><script type="text/javascript" src="../__includes/full_scene/includes/PostProcess/Bloom.js"></script><script type="text/javascript" src="../__includes/full_scene/includes/PostProcess/DepthOfFieldScaleDownPCF.js"></script><script type="text/javascript" src="../__includes/full_scene/includes/OrbitControls.js"></script><script type="text/javascript" src="webgl1.0test.js"></script><link rel="stylesheet" href="../__includes/styles.css" type="text/css"><script type="text/javascript" src="../__includes/ColladaLoader.js"></script><script type="text/javascript" src="test.js"></script><body>
<div id="brand-header">
    <img src="/images/web30_header.png" alt="Basemark Web 3.0 Total test time: 3-20 min, Mobile: Use charger, Keep screen alive!" style="max-width: 100%; max-height: 60px">
</div>
<div class="container" style="margin-left: 0; margin-right: 0">
    <script id="genericVertexShader" type="x-shader/x-vertex">
            attribute vec4 tangent;
			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vPos;


			void main()	{
				vNormal = (modelMatrix * vec4(normal,0.0)).xyz;
				vTangent = normalMatrix * tangent.xyz;
				vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
				vec4 worldPos = modelMatrix * vec4(position, 1.0);
				vPos = mvPos.xyz;

				gl_Position = projectionMatrix * mvPos;

			}
		</script>

    <script id="genericFragmentShader" type="x-shader/x-fragment">
            uniform float light_intensity;
            uniform float light_ambient;
            uniform vec3 light_color;
            uniform float moon_light_sharpness;
            uniform float moon_light_spread;

			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vPos;
            varying vec3 tangent;
			uniform vec3 moon_light_dir;
			uniform vec3 moon_light_pos;


			void main()	{
                float ambient = light_ambient;
                vec3 plight = normalize(moon_light_pos - vPos);
                vec3 dlight = normalize(moon_light_dir);
                float diff = max(0.0,dot(normalize(vNormal), plight));
                vec3 eye = normalize(-vPos);
                float spec = pow(max(0.0,dot(normalize(vNormal), normalize(eye + plight) )), 128.0);

                float lit = light_intensity*(diff + spec);
                float spot_effect = min(1.0,moon_light_sharpness * pow(max(0.0,dot(plight, dlight)), moon_light_spread));

				gl_FragColor = (ambient + lit*spot_effect)*vec4(light_color,1.0)*0.3;
			}

		</script>



    <script id="particleVertexShader" type="x-shader/x-vertex">
            uniform float size;
            uniform float scale;
            uniform float timer;

            varying vec4 mvPosition;
            varying vec3 pN;
            varying vec3 up;
            uniform sampler2D noise;

            void main()
            {
                vec4 anim_pos = vec4( position.x, position.y - timer*0.5, position.z, 1.0 );

                if (anim_pos.y < 0.0) anim_pos.y += 20.0;
                if (anim_pos.y < 0.0) anim_pos.y += 20.0;
                if (anim_pos.y < 0.0) anim_pos.y += 20.0;
                //pN = vec3(position.x/5.0,(anim_pos.y/10.0) - 1.0,position.z/5.0);
                vec2 UV = vec2(position.x/5.0+0.5, position.z/5.0+0.5)*(timer/2.0+60.0)/60.0;

                vec3 noise_p = texture2D( noise, UV).xyz;

                pN = noise_p*2.0 - vec3(1.0);

                mvPosition = modelViewMatrix * anim_pos;

                up = normalMatrix * vec3(0.0,0.0,1.0);

                gl_PointSize = (noise_p.z + 0.3)*size * ( scale / length( mvPosition.xyz ) );
                gl_Position = projectionMatrix * mvPosition;
            }
		</script>


    <script id="particleFragmentShader" type="x-shader/x-fragment">
            uniform vec3 drop_color;
            uniform float opacity;

            varying vec4 mvPosition;
            varying vec3 pN;
            varying vec3 up;

            uniform vec4 offsetRepeat;
            uniform sampler2D map;
            uniform float contrast;
            uniform float strength;


            void main() {
                vec4 frontColor = vec4(drop_color,1.0);
                frontColor.a *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy ).a;

                vec4 upColor = frontColor;
                vec2 aux = vec2(abs(0.5 - gl_PointCoord.x), abs(gl_PointCoord.y - 0.5));
                upColor.a = max(0.0,(1.0 - aux.x*aux.x - aux.y*aux.y)*10000.0 - 9999.0);


                vec3 eye = normalize(-mvPosition.xyz);
                vec3 N = normalize(pN);
                float spec = pow(clamp(dot(N, normalize(eye + vec3(-0.6,0.8,0.0) ) ),0.0,1.0), 128.0*contrast);//pow(max(0.0,dot(vec3(0.0,1.0,0.0), normalize(eye + vec3(0.6,0.8,0.0) ) )), 64.0);

                vec4 final;

                vec3 nup = normalize(up);

                final = mix(frontColor, upColor, nup.y*nup.y );
                final *= (1.0 + spec*5.0*strength);

                gl_FragColor = final;
            }
		</script>


    <script id="metallicVertexShader" type="x-shader/x-vertex">

            attribute vec4 tangent;

			varying mat3 tbn;
			varying vec2 vTexel;
			varying vec2 lTexel;
			varying vec4 worldPos;
			varying vec4 viewPos;
            varying vec4 projPos;

			void main()	{
                vec3 vNormal = normalMatrix * normal;
				vec3 vTangent = normalMatrix * tangent.xyz;
                vec3 binormal = cross(normal,tangent.xyz);
                vec3 vBinormal = normalMatrix * binormal;

                //tbn = mat3(vTangent,vBinormal,vNormal);
                tbn = mat3(vTangent,vBinormal,vNormal);


				viewPos = modelViewMatrix * vec4(position, 1.0);
				worldPos = modelMatrix * vec4(position, 1.0);
                vTexel = uv;
                lTexel = uv2;


                /*
                vec4 L = viewMatrix * vec4(pl_pos[0],1.0) - viewPos;
                pl_L[0] = L.xyz;
                L = viewMatrix * vec4(pl_pos[1],1.0) - viewPos;
                pl_L[1] = L.xyz;
                L = viewMatrix * vec4(pl_pos[2],1.0) - viewPos;
                pl_L[2] = L.xyz;
                */

                //dirLight.x = dot( dir_light, tangent.xyz );
                //dirLight.y = dot( dir_light, binormal );
                //dirLight.z = dot( dir_light, normal );

                projPos = projectionMatrix * viewPos;

				gl_Position = projPos;

			}
		</script>

    <script id="metallicPixelShader" type="x-shader/x-fragment">

            uniform sampler2D diffuse;
            uniform sampler2D material_map;
            uniform sampler2D light_map;
            uniform sampler2D environment_map;
            uniform sampler2D environment_rough_map;
            uniform sampler2D normal_map;

            uniform float mat_base_metal;
            uniform float mat_overall_metallness;
            uniform float mat_metalmap_contr;
            uniform float mat_base_gloss;
            uniform float mat_gloss_contr;
            uniform float mat_glossiness;
            uniform vec3  specular_albedo;

            uniform float light_intensity;
            uniform float light_ambient;
            uniform vec3 light_color;
            uniform float moon_light_sharpness;
            uniform float moon_light_spread;

            uniform float pl_intensity[3];
            uniform float pl_ambient[3];
            uniform float pl_inner[3];
            uniform float pl_outer[3];
            uniform vec3  pl_color[3];
            uniform vec3 pl_pos[3];
            uniform float shadow_strength;
			uniform vec3 moon_light_dir;
			uniform vec3 moon_light_pos;

			varying mat3 tbn;
			varying vec2 vTexel;
			varying vec2 lTexel;
			varying vec4 worldPos;
			varying vec4 viewPos;
            varying vec4 projPos;

            #define PI      3.1415
            #define InvPI   1.0/PI


            vec3 fresnelSchlick(vec3 spec, float glossiness,vec3 E, vec3 H)
            {
                return spec + ( vec3(1.0) - spec) * pow(1.0 - max(0.0,dot(E, H)), 5.0);
            }

            float GSchlick(vec3 L, vec3 N, float k)
            {
                float dp = max(0.0,dot(L, N));
                return dp/(dp * ( 1.0 - k ) + k);
            }

            float geometricSmithSchlick(vec3 L, vec3 E, vec3 N, float glossiness)
            {
                float k = sqrt( (2.0 * pow(1.0 - glossiness,2.0)) * InvPI );
                float GS = GSchlick(L, N,k);
                return  GS * GS / (4.0 * dot(N,E) * dot(N, L));
            }

            float distributionTrowbridgeReitz(vec3 H, vec3 N, float glossiness)
            {
                float r = clamp(1.0 - glossiness,0.08,1.0);
                float r2 = r*r;
                float HdotN = clamp(dot(H, N), 0.0, 0.999999 );
                return (0.1 + glossiness*0.9) *r2 / ( pow(pow( HdotN, 2.0) * (r2 - 1.0) + 1.0, 2.0) );
            }

            float geometricSmithTrowbridgeReitz(vec3 L, vec3 E, vec3 N, float glossiness)
            {
                float r = clamp(1.0 - glossiness,0.05,1.0);
                float r2 = r*r;
                float NdotV = dot(E, N);
                float NdotL = dot(L, N);
                float Gview = NdotV + sqrt( (NdotV - NdotV * r2) * NdotV + r2 );
                float Glight = NdotL + sqrt( (NdotL - NdotL * r2) * NdotL + r2 );
                return ( Gview * Glight );
            }

            float geometricTorranceSparrowApprox(vec3 E, vec3 H)
            {
                vec3 h = E + H;
                return 1.0/(dot(h,h));
            }

            float geometricTorranceSparrow(vec3 L, vec3 E,vec3 N, vec3 H)
            {
                float NdotH = dot(N, H);
                float invVDotH = 1.0/(dot(E, H));
                float ret = min( (2.0 * NdotH * dot(N, E)) * invVDotH, (2.0 * NdotH * dot(N, L)) * invVDotH );
                return (4.0 * dot(N,E) * dot(N, L))/min( 1.0, ret );
            }

            vec4 specular_color;

            vec4 reflectionMap(vec3 eye, vec3 N, float glossiness);
            vec4 spotLighting(vec3 L, vec3 N, float gloss);
            vec4 pointLighting1(vec3 N, float gloss);
            vec4 pointLighting2(vec3 N, float gloss);
            vec4 pointLighting3(vec3 N, float gloss);

			void main()	{
                vec3 eye = normalize(cameraPosition - worldPos.xyz);
                vec3 normal = 2.0*texture2D(normal_map,vTexel).xyz - vec3(1.0);
                vec3 wnormal = normalize(tbn * normal);
                normal = wnormal;
                wnormal = (vec4(wnormal,0.0) * viewMatrix).xyz;
                vec4 albedo_pixel = texture2D( diffuse, vTexel );
                float metallness = (texture2D( material_map, vTexel ).r*mat_metalmap_contr + mat_base_metal)*mat_overall_metallness;
                float gloss = min(1.0,(mat_base_gloss + (1.0 - texture2D( material_map, vTexel ).g)*mat_gloss_contr)*mat_glossiness);
                vec4 metal_pixel = reflectionMap(eye,wnormal,gloss);
                vec4 color;
                vec4 lights;
                float shadow_contr = max(0.0,texture2D( light_map, lTexel ).r*shadow_strength + 1.0 - shadow_strength);


            #ifdef MULTI_PASS_REFLECTION
                specular_color = vec4(specular_albedo,1.0);
                color = mix(albedo_pixel, metal_pixel*specular_color, min(1.0,metallness)*metal_pixel.a );
            #else
                specular_color = vec4(specular_albedo,1.0) * albedo_pixel;
                color = mix(specular_color, metal_pixel, min(1.0,metallness));
            #endif


                lights = light_ambient + shadow_contr*(spotLighting(normalize(moon_light_pos - viewPos.xyz),normal,gloss) + pointLighting1(normal,gloss) + pointLighting2(normal,gloss))+ pointLighting3(normal,gloss);


                gl_FragColor = color*lights;
				//gl_FragColor = texture2D( normal_map, vTexel );
			}

            vec4 spotLighting(vec3 L, vec3 N, float gloss)
            {
                vec3 DL = normalize(moon_light_dir);

                vec3 E = normalize(-viewPos.xyz);
                float diff = max(0.0,dot(N, L));
                //float spec = pow(max(0.0,dot(N, normalize(eye + L) )), 2.0 + 30.0*gloss)*specularity;
                vec3 H = normalize(E + L);
                //float spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithSchlick(L,E,N,gloss)*fresnelSchlick(specularity, gloss, E, H)*diff;
                //float spec = distributionTrowbridgeReitz(H,N,gloss)*geometricTorranceSparrow(L,E,H,N)*fresnelSchlick(specularity, gloss, E, H)*diff;
                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(specular_color.rgb, gloss, E, H)*diff;
                diff *= (1.0 - (specular_color.r + specular_color.g + specular_color.b)*0.3333333);

                vec4 lit = (vec4(diff) + vec4(spec,1.0))*light_intensity;
                float spot_effect = min(1.0,moon_light_sharpness * pow(max(0.0,dot(L, DL)), moon_light_spread));

                return lit*spot_effect*vec4(light_color,1.0);
            }

            vec4 pointLighting1(vec3 N, float gloss)
            {
                vec3 L = pl_pos[0] - viewPos.xyz;
                float d = length(L);
                if (d >= pl_outer[0]) return vec4(0.0);

                L = normalize(L);
                vec3 E = normalize(-viewPos.xyz);
                float ambient = pl_ambient[0];
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);

                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(specular_color.rgb, gloss, E, H)*diff;
                diff *= (1.0 - (specular_color.r + specular_color.g + specular_color.b)*0.3333333);

                vec4 light = (vec4(ambient + diff) + vec4(spec,1.0))*pl_intensity[0]*vec4(pl_color[0],1.0);
                float attenuation;
                if (d <= pl_inner[0])
                    attenuation = 1.0;
                else
                    attenuation = min(1.0, 1.0 - (d - pl_inner[0])/(pl_outer[0] - pl_inner[0]) );


                return light*attenuation;
            }
            vec4 pointLighting2(vec3 N, float gloss)
            {
                vec3 L = pl_pos[1] - viewPos.xyz;
                float d = length(L);
                if (d >= pl_outer[1]) return vec4(0.0);

                L = normalize(L);
                vec3 E = normalize(-viewPos.xyz);
                float ambient = pl_ambient[1];
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);

                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(specular_color.rgb, gloss, E, H)*diff;
                diff *= (1.0 - (specular_color.r + specular_color.g + specular_color.b)*0.3333333);

                vec4 light = (vec4(ambient + diff) + vec4(spec,1.0))*pl_intensity[1]*vec4(pl_color[1],1.0);
                float attenuation;
                if (d <= pl_inner[1])
                    attenuation = 1.0;
                else
                    attenuation = min(1.0, 1.0 - (d - pl_inner[1])/(pl_outer[1] - pl_inner[1]) );


                return light*attenuation;
            }
            vec4 pointLighting3(vec3 N, float gloss)
            {
                vec3 L = pl_pos[2] - viewPos.xyz;
                float d = length(L);
                if (d >= pl_outer[2]) return vec4(0.0);

                L = normalize(L);
                vec3 E = normalize(-viewPos.xyz);
                float ambient = pl_ambient[2];
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);

                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(specular_color.rgb, gloss, E, H)*diff;
                diff *= (1.0 - (specular_color.r + specular_color.g + specular_color.b)*0.3333333);

                vec4 light = (vec4(ambient + diff) + vec4(spec,1.0))*pl_intensity[2]*vec4(pl_color[2],1.0);
                float attenuation;
                if (d <= pl_inner[2])
                    attenuation = 1.0;
                else
                    attenuation = min(1.0, 1.0 - (d - pl_inner[2])/(pl_outer[2] - pl_inner[2]) );


                return light*attenuation;
            }

            vec4 reflectionMap(vec3 eye, vec3 N, float glossiness)
            {
            #ifdef MULTI_PASS_REFLECTION
                vec2 pref = projPos.xy;
                pref = vec2(1.0) + pref*vec2(1.0 / projPos.w);
                pref *= vec2(0.5);
                pref += (N.xz)*0.065;

                vec4 pure_refl = texture2D(environment_map, pref);
                return pure_refl;
            #else
                vec3 r_eye = reflect(eye,N);
                r_eye = normalize(r_eye);

                vec2 pref;
                pref.x = r_eye.x / sqrt( r_eye.x*r_eye.x + r_eye.y*r_eye.y + (r_eye.z)*(r_eye.z) );
                pref.y = r_eye.y / sqrt( r_eye.x*r_eye.x + r_eye.y*r_eye.y + (r_eye.z)*(r_eye.z) );
                pref.x = 0.5 + pref.x /2.0;
                pref.y = 0.5 + pref.y /2.0;

                vec4 pure_refl = texture2D(environment_map, pref);

                if (glossiness >= 1.0) return pure_refl;

                vec4 rough_refl = texture2D(environment_rough_map, pref);

                if (glossiness <= 0.0) return rough_refl;

                return mix(rough_refl, pure_refl,glossiness);
            #endif
            }
		</script>




    <script id="robotVertexShader" type="x-shader/x-vertex">

            attribute vec4 tangent;


			varying mat3 tbn;
			varying vec2 vTexel;
			varying vec2 lTexel;
			varying vec4 worldPos;
			varying vec4 viewPos;


			void main()	{
                vec3 vNormal = normalMatrix * normal;
				vec3 vTangent = normalMatrix * tangent.xyz;
                vec3 binormal = cross(normal,tangent.xyz);
                vec3 vBinormal = normalMatrix * binormal;

                //tbn = mat3(vTangent,vBinormal,vNormal);
                tbn = mat3(vTangent,vBinormal,vNormal);


				viewPos = modelViewMatrix * vec4(position, 1.0);
				worldPos = modelMatrix * vec4(position, 1.0);
                vTexel = uv;
                lTexel = uv2;

				gl_Position = projectionMatrix * viewPos;

			}
		</script>

    <script id="robotPixelShader" type="x-shader/x-fragment">

            uniform sampler2D diffuse;
            uniform sampler2D material_map;
            uniform sampler2D environment_map;
            uniform sampler2D environment_rough_map;
            uniform sampler2D normal_map;
            uniform sampler2D noise_map;
            uniform sampler2D light_map;

            uniform float mat_base_metal;
            uniform float mat_overall_metallness;
            uniform float mat_metalmap_contr;
            uniform float mat_base_gloss;
            uniform float mat_gloss_contr;
            uniform float mat_glossiness;
            uniform vec3  specular_albedo;

            uniform float light_intensity;
            uniform float light_ambient;
            uniform vec3 light_color;
            uniform float moon_light_sharpness;
            uniform float moon_light_spread;
            uniform float timer;
            uniform float shadow_strength;
            uniform float drop_size;

            uniform float pl_intensity[3];
            uniform float pl_ambient[3];
            uniform float pl_inner[3];
            uniform float pl_outer[3];
            uniform vec3  pl_color[3];
            uniform vec3 pl_pos[3];
			uniform vec3 moon_light_dir;
			uniform vec3 moon_light_pos;

			varying mat3 tbn;
			varying vec2 vTexel;
			varying vec2 lTexel;
			varying vec4 worldPos;
			varying vec4 viewPos;

            #define PI      3.1415
            #define InvPI   1.0/PI


            vec3 fresnelSchlick(vec3 spec, float glossiness,vec3 E, vec3 H)
            {
                return spec + ( vec3(1.0) - spec) * pow(1.0 - max(0.0,dot(E, H)), 5.0);
            }

            float GSchlick(vec3 L, vec3 N, float k)
            {
                float dp = max(0.0,dot(L, N));
                return dp/(dp * ( 1.0 - k ) + k);
            }

            float geometricSmithSchlick(vec3 L, vec3 E, vec3 N, float glossiness)
            {
                float k = sqrt( (2.0 * pow(1.0 - glossiness,2.0)) * InvPI );
                float GS = GSchlick(L, N,k);
                return  GS * GS / (4.0 * dot(N,E) * dot(N, L));
            }

            float distributionTrowbridgeReitz(vec3 H, vec3 N, float glossiness)
            {
                float r = clamp(1.0 - glossiness,0.08,1.0);
                float r2 = r*r;
                float HdotN = clamp(dot(H, N), 0.0, 0.999999 );
                return (0.1 + glossiness*0.9) *r2 / ( pow(pow( HdotN, 2.0) * (r2 - 1.0) + 1.0, 2.0) );
            }

            float geometricSmithTrowbridgeReitz(vec3 L, vec3 E, vec3 N, float glossiness)
            {
                float r = clamp(1.0 - glossiness,0.05,1.0);
                float r2 = r*r;
                float NdotV = dot(E, N);
                float NdotL = dot(L, N);
                float Gview = NdotV + sqrt( (NdotV - NdotV * r2) * NdotV + r2 );
                float Glight = NdotL + sqrt( (NdotL - NdotL * r2) * NdotL + r2 );
                return ( Gview * Glight );
            }

            float geometricTorranceSparrowApprox(vec3 E, vec3 H)
            {
                vec3 h = E + H;
                return 1.0/(dot(h,h));
            }

            float geometricTorranceSparrow(vec3 L, vec3 E,vec3 N, vec3 H)
            {
                float NdotH = dot(N, H);
                float invVDotH = 1.0/(dot(E, H));
                float ret = min( (2.0 * NdotH * dot(N, E)) * invVDotH, (2.0 * NdotH * dot(N, L)) * invVDotH );
                return (4.0 * dot(N,E) * dot(N, L))/min( 1.0, ret );
            }

            vec4 specular_color;

            vec4 reflectionMap(vec3 eye, vec3 N, float glossiness);
            vec4 spotLighting(vec3 L, vec3 N, float gloss);
            vec4 pointLighting1(vec3 N, float gloss);
            vec4 pointLighting2(vec3 N, float gloss);
            vec4 pointLighting3(vec3 N, float gloss);

			void main()	{
                vec3 eye = normalize(cameraPosition - worldPos.xyz);
                vec3 normal = 2.0*texture2D(normal_map,vTexel).xyz - vec3(1.0);
                vec3 wnormal = normalize(tbn * normal);
                normal = wnormal;
                wnormal = (vec4(wnormal,0.0) * viewMatrix).xyz;
                vec4 albedo_pixel = texture2D( diffuse, vTexel );
                float metallness = (texture2D( material_map, vTexel ).r*mat_metalmap_contr + mat_base_metal)*mat_overall_metallness;
                float gloss = min(1.0,(mat_base_gloss + (1.0 - texture2D( material_map, vTexel ).g)*mat_gloss_contr)*mat_glossiness);
                vec4 metal_pixel = reflectionMap(eye,wnormal,gloss);
                vec4 color;
                vec4 lights;
                float shadow_contr = max(0.0,texture2D( light_map, lTexel ).r*shadow_strength + 1.0 - shadow_strength);



                vec2 pref;
                pref.x = (worldPos.x) / sqrt( (worldPos.x)*(worldPos.x) + (worldPos.y)*(worldPos.y) + (worldPos.z)*(worldPos.z) );
                pref.y = (worldPos.y) / sqrt( (worldPos.x)*(worldPos.x) + (worldPos.y)*(worldPos.y)  + (worldPos.z)*(worldPos.z) );
                pref.x = 0.5 + pref.x /2.0;
                pref.y = 0.5 + pref.y /2.0;

                vec2 drop_t = vec2( pref.x,pref.y + worldPos.z*0.1)*(2.0 - drop_size) + vec2(0.0,timer*0.003);
                //vec2 drop_t = vec2( -abs(worldPos.x) +abs(worldPos.z),worldPos.y + (worldPos.x)*2.0)*0.1 + vec2(0.0,timer*0.003);
                vec3 noise = texture2D( noise_map, drop_t ).rgb;
                vec3 noise_n = normalize(noise*2.0 - vec3(1.0));
                vec3 noise_xp = normalize(texture2D( noise_map, drop_t + vec2(0.00199,0.0) ).rgb*2.0 - vec3(1.0));
                vec3 noise_xn = normalize(texture2D( noise_map, drop_t + vec2(-0.00199,0.0) ).rgb*2.0 - vec3(1.0));
                vec3 noise_yp = normalize(texture2D( noise_map, drop_t + vec2(0.0,-0.00199) ).rgb*2.0 - vec3(1.0));
                vec3 noise_yn = normalize(texture2D( noise_map, drop_t + vec2(0.0,0.00199) ).rgb*2.0 - vec3(1.0));

                float drop_s = pow(max(0.0,dot(normalize(worldPos.xyz),noise_n)),32.0);
                float drop_sxp = pow(max(0.0,dot(normalize(worldPos.xyz),noise_xp)),32.0);
                float drop_sxn = pow(max(0.0,dot(normalize(worldPos.xyz),noise_xn)),32.0);
                float drop_syp = pow(max(0.0,dot(normalize(worldPos.xyz),noise_yp)),32.0);
                float drop_syn = pow(max(0.0,dot(normalize(worldPos.xyz),noise_yn)),32.0);


                vec3 drop_n = normalize(tbn * (vec3(drop_sxn - drop_sxp, drop_syp - drop_syn,0.001 + drop_s*0.5)) );

                vec2 uv_disp = drop_n.xy*0.1/(1.0 + drop_n.z);
                vec4 drop = texture2D( diffuse, vTexel + uv_disp );//vec4(drop_n,1.0)*z;
                albedo_pixel = mix(albedo_pixel, drop, drop_s);
                metallness = min(1.0,metallness + drop_s*0.2);
                gloss = min(1.0,gloss + drop_s*0.6);
                normal = normalize(normal*(1.0 - drop_s) + drop_n*drop_s);



                specular_color = vec4(specular_albedo,1.0) * albedo_pixel;

                color = mix(specular_color, metal_pixel*specular_color, min(1.0,metallness));
                lights = light_ambient + shadow_contr*(spotLighting(normalize(moon_light_pos - viewPos.xyz),normal,gloss) + pointLighting1(normal,gloss) + pointLighting2(normal,gloss)) + pointLighting3(normal,gloss);


                gl_FragColor = color*lights;
			}

            vec4 spotLighting(vec3 L, vec3 N, float gloss)
            {
                vec3 DL = normalize(moon_light_dir);

                vec3 E = normalize(-viewPos.xyz);
                float diff = max(0.0,dot(N, L));
                //float spec = pow(max(0.0,dot(N, normalize(eye + L) )), 2.0 + 30.0*gloss)*specularity;
                vec3 H = normalize(E + L);
                //float spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithSchlick(L,E,N,gloss)*fresnelSchlick(specularity, gloss, E, H)*diff;
                //float spec = distributionTrowbridgeReitz(H,N,gloss)*geometricTorranceSparrow(L,E,H,N)*fresnelSchlick(specularity, gloss, E, H)*diff;
                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(specular_color.rgb, gloss, E, H)*diff;
                diff *= (1.0 - (specular_color.r + specular_color.g + specular_color.b)*0.3333333);

                vec4 lit = (vec4(diff) + vec4(spec,1.0))*light_intensity;
                float spot_effect = min(1.0,moon_light_sharpness * pow(max(0.0,dot(L, DL)), moon_light_spread));

                return  lit*spot_effect*vec4(light_color,1.0);
            }

            vec4 pointLighting1(vec3 N, float gloss)
            {
                vec3 L = pl_pos[0] - viewPos.xyz;
                float d = length(L);
                if (d >= pl_outer[0]) return vec4(0.0);

                L = normalize(L);
                vec3 E = normalize(-viewPos.xyz);
                float ambient = pl_ambient[0];
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);

                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(specular_color.rgb, gloss, E, H)*diff;
                diff *= (1.0 - (specular_color.r + specular_color.g + specular_color.b)*0.3333333);

                vec4 light = (vec4(ambient + diff) + vec4(spec,1.0))*pl_intensity[0]*vec4(pl_color[0],1.0);
                float attenuation;
                if (d <= pl_inner[0])
                    attenuation = 1.0;
                else
                    attenuation = min(1.0, 1.0 - (d - pl_inner[0])/(pl_outer[0] - pl_inner[0]) );


                return light*attenuation;
            }
            vec4 pointLighting2(vec3 N, float gloss)
            {
                vec3 L = pl_pos[1] - viewPos.xyz;
                float d = length(L);
                if (d >= pl_outer[1]) return vec4(0.0);

                L = normalize(L);
                vec3 E = normalize(-viewPos.xyz);
                float ambient = pl_ambient[1];
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);

                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(specular_color.rgb, gloss, E, H)*diff;
                diff *= (1.0 - (specular_color.r + specular_color.g + specular_color.b)*0.3333333);

                vec4 light = (vec4(ambient + diff) + vec4(spec,1.0))*pl_intensity[1]*vec4(pl_color[1],1.0);
                float attenuation;
                if (d <= pl_inner[1])
                    attenuation = 1.0;
                else
                    attenuation = min(1.0, 1.0 - (d - pl_inner[1])/(pl_outer[1] - pl_inner[1]) );


                return light*attenuation;
            }
            vec4 pointLighting3(vec3 N, float gloss)
            {
                vec3 L = pl_pos[2] - viewPos.xyz;
                float d = length(L);
                if (d >= pl_outer[2]) return vec4(0.0);

                L = normalize(L);
                vec3 E = normalize(-viewPos.xyz);
                float ambient = pl_ambient[2];
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);

                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(specular_color.rgb, gloss, E, H)*diff;
                diff *= (1.0 - (specular_color.r + specular_color.g + specular_color.b)*0.3333333);

                vec4 light = (vec4(ambient + diff) + vec4(spec,1.0))*pl_intensity[2]*vec4(pl_color[2],1.0);
                float attenuation;
                if (d <= pl_inner[2])
                    attenuation = 1.0;
                else
                    attenuation = min(1.0, 1.0 - (d - pl_inner[2])/(pl_outer[2] - pl_inner[2]) );


                return light*attenuation;
            }

            vec4 reflectionMap(vec3 eye, vec3 N, float glossiness)
            {
                vec3 r_eye = reflect(eye,N);
                r_eye = normalize(r_eye);

                vec2 pref;
                pref.x = r_eye.x / sqrt( r_eye.x*r_eye.x + r_eye.y*r_eye.y + (r_eye.z)*(r_eye.z) );
                pref.y = r_eye.y / sqrt( r_eye.x*r_eye.x + r_eye.y*r_eye.y + (r_eye.z)*(r_eye.z) );
                pref.x = 0.5 + pref.x /2.0;
                pref.y = 0.5 + pref.y /2.0;

                vec4 pure_refl = texture2D(environment_map, pref);

                if (glossiness >= 1.0) return pure_refl;

                vec4 rough_refl = texture2D(environment_rough_map, pref);

                if (glossiness <= 0.0) return rough_refl;

                return mix(rough_refl, pure_refl,glossiness);
            }
		</script>



    <script id="transpDecalVertexShader" type="x-shader/x-vertex">
			varying vec3 pl_L[3];
			varying vec2 vTexel;
			varying vec2 lTexel;
			varying vec4 worldPos;
			varying vec4 viewPos;
			varying vec3 vNormal;

            uniform vec3 pl_pos[3];

			void main()	{
                vNormal = normalMatrix * normal;

				viewPos = modelViewMatrix * vec4(position, 1.0);
				worldPos = modelMatrix * vec4(position, 1.0);
                vTexel = uv;
                lTexel = uv2;

                vec4 L = viewMatrix * vec4(pl_pos[0],1.0) - viewPos;
                pl_L[0] = L.xyz;
                L = viewMatrix * vec4(pl_pos[1],1.0) - viewPos;
                pl_L[1] = L.xyz;
                L = viewMatrix * vec4(pl_pos[2],1.0) - viewPos;
                pl_L[2] = L.xyz;

                //dirLight.x = dot( dir_light, tangent.xyz );
                //dirLight.y = dot( dir_light, binormal );
                //dirLight.z = dot( dir_light, normal );


				gl_Position = projectionMatrix * viewPos;

			}
		</script>

    <script id="transpDecalPixelShader" type="x-shader/x-fragment">

            uniform sampler2D diffuse;
            uniform sampler2D light_map;

            uniform float mat_glossiness;
            uniform float  mat_specularity;

            uniform float light_intensity;
            uniform float light_ambient;
            uniform vec3 light_color;
            uniform float moon_light_sharpness;
            uniform float moon_light_spread;

            uniform float pl_intensity[3];
            uniform float pl_ambient[3];
            uniform float pl_inner[3];
            uniform float pl_outer[3];
            uniform vec3  pl_color[3];
            uniform float shadow_strength;
			uniform vec3 moon_light_dir;
			uniform vec3 moon_light_pos;

			varying vec2 vTexel;
			varying vec2 lTexel;
			varying vec3 pl_L[3];
			varying vec4 worldPos;
			varying vec4 viewPos;
			varying vec3 vNormal;

            #define PI      3.1415
            #define InvPI   1.0/PI


            vec3 fresnelSchlick(vec3 spec, float glossiness,vec3 E, vec3 H)
            {
                return spec + ( vec3(1.0) - spec) * pow(1.0 - max(0.0,dot(E, H)), 5.0);
            }

            float GSchlick(vec3 L, vec3 N, float k)
            {
                float dp = max(0.0,dot(L, N));
                return dp/(dp * ( 1.0 - k ) + k);
            }

            float distributionTrowbridgeReitz(vec3 H, vec3 N, float glossiness)
            {
                float r = clamp(1.0 - glossiness,0.08,1.0);
                float r2 = r*r;
                float HdotN = clamp(dot(H, N), 0.0, 0.999999 );
                return (0.1 + glossiness*0.9) *r2 / ( pow(pow( HdotN, 2.0) * (r2 - 1.0) + 1.0, 2.0) );
            }

            float geometricSmithTrowbridgeReitz(vec3 L, vec3 E, vec3 N, float glossiness)
            {
                float r = clamp(1.0 - glossiness,0.05,1.0);
                float r2 = r*r;
                float NdotV = dot(E, N);
                float NdotL = dot(L, N);
                float Gview = NdotV + sqrt( (NdotV - NdotV * r2) * NdotV + r2 );
                float Glight = NdotL + sqrt( (NdotL - NdotL * r2) * NdotL + r2 );
                return ( Gview * Glight );
            }

            vec4 spotLighting(vec3 L, vec3 N, float gloss);
            vec4 pointLighting1(vec3 N, float gloss);
            vec4 pointLighting2(vec3 N, float gloss);
            vec4 pointLighting3(vec3 N, float gloss);

			void main()	{
                vec3 eye = normalize(cameraPosition - worldPos.xyz);
                vec3 normal = normalize(vNormal);
                vec4 albedo_pixel = texture2D( diffuse, vTexel );
                float gloss = mat_glossiness;
                vec4 color;
                vec4 lights;
                float shadow_contr = max(0.0,texture2D( light_map, lTexel ).r*shadow_strength + 1.0 - shadow_strength);

                lights = light_ambient + shadow_contr*(spotLighting(normalize(moon_light_pos - viewPos.xyz),normal,gloss) + pointLighting1(normal,gloss) + pointLighting2(normal,gloss)) + pointLighting3(normal,gloss);
                lights.a = 1.0;

                gl_FragColor = albedo_pixel*lights;
			}

            vec4 spotLighting(vec3 L, vec3 N, float gloss)
            {
                vec3 DL = normalize(moon_light_dir);

                vec3 E = normalize(-viewPos.xyz);
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);
                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(vec3(mat_specularity), gloss, E, H)*diff;
                diff *= (1.0 - mat_specularity);

                vec4 lit = (vec4(diff) + vec4(spec,1.0))*light_intensity;
                float spot_effect = min(1.0,moon_light_sharpness * pow(max(0.0,dot(L, DL)), moon_light_spread));

                return lit*spot_effect*vec4(light_color,1.0);
            }

            vec4 pointLighting1(vec3 N, float gloss)
            {
                vec3 L = pl_L[0];
                float d = length(L);
                if (d >= pl_outer[0]) return vec4(0.0);

                L = normalize(L);
                vec3 E = normalize(-viewPos.xyz);
                float ambient = pl_ambient[0];
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);

                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(vec3(mat_specularity), gloss, E, H)*diff;
                diff *= (1.0 - mat_specularity);

                vec4 light = (vec4(ambient + diff) + vec4(spec,1.0))*pl_intensity[0]*vec4(pl_color[0],1.0);
                float attenuation;
                if (d <= pl_inner[0])
                    attenuation = 1.0;
                else
                    attenuation = min(1.0, 1.0 - (d - pl_inner[0])/(pl_outer[0] - pl_inner[0]) );


                return light*attenuation;
            }
            vec4 pointLighting2(vec3 N, float gloss)
            {
                vec3 L = pl_L[1];
                float d = length(L);
                if (d >= pl_outer[1]) return vec4(0.0);

                L = normalize(L);
                vec3 E = normalize(-viewPos.xyz);
                float ambient = pl_ambient[1];
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);

                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(vec3(mat_specularity), gloss, E, H)*diff;
                diff *= (1.0 - mat_specularity);

                vec4 light = (vec4(ambient + diff) + vec4(spec,1.0))*pl_intensity[1]*vec4(pl_color[1],1.0);
                float attenuation;
                if (d <= pl_inner[1])
                    attenuation = 1.0;
                else
                    attenuation = min(1.0, 1.0 - (d - pl_inner[1])/(pl_outer[1] - pl_inner[1]) );


                return light*attenuation;
            }
            vec4 pointLighting3(vec3 N, float gloss)
            {
                vec3 L = pl_L[2];
                float d = length(L);
                if (d >= pl_outer[2]) return vec4(0.0);

                L = normalize(L);
                vec3 E = normalize(-viewPos.xyz);
                float ambient = pl_ambient[2];
                float diff = max(0.0,dot(N, L));
                vec3 H = normalize(E + L);

                vec3 spec = distributionTrowbridgeReitz(H,N,gloss)*geometricSmithTrowbridgeReitz(L,E,N,gloss)*fresnelSchlick(vec3(mat_specularity), gloss, E, H)*diff;
                diff *= (1.0 - mat_specularity);

                vec4 light = (vec4(ambient + diff) + vec4(spec,1.0))*pl_intensity[2]*vec4(pl_color[2],1.0);
                float attenuation;
                if (d <= pl_inner[2])
                    attenuation = 1.0;
                else
                    attenuation = min(1.0, 1.0 - (d - pl_inner[2])/(pl_outer[2] - pl_inner[2]) );


                return light*attenuation;
            }
		</script>



    <script id="emissiveVertexShader" type="x-shader/x-vertex">

			varying vec3 vNormal;
			varying vec4 viewPos;

			void main()	{
                vNormal = normalMatrix * normal;
				viewPos = modelViewMatrix * vec4(position, 1.0);

				gl_Position = projectionMatrix * viewPos;

			}
		</script>

    <script id="emissivePixelShader" type="x-shader/x-fragment">

            uniform vec3 emission;
			varying vec3 vNormal;
			varying vec4 viewPos;
			void main()	{
                vec3 N = normalize(vNormal);
                vec3 V = normalize(-viewPos.xyz);

                float s = min(1.0,pow(max(0.0,dot(N,V)),8.0)*4.0);

                gl_FragColor = vec4(emission,s);
			}

		</script>
    <h1>WebGL 1.0.2 Test (test 4/20)</h1>
    <div id="webgl-102-test-content-area">
    </div>
</div>
<script type="text/javascript">
  var debug = false;

  var testContainerName = 'webgl-102-test-content-area';

  BasemarkWebEngine.runTest();
</script>
</body>

</html>